{
    "contents" : "\n# Methods:\n#m1 print output\nprint.forestFloor = function(ff) {\n cat(\"this is a forestFloor('ff') object \\n\nthis object can be plotted in 2D with plot(ff), see help(plot.forestFloor) \\n\nthis object can be plotted in 3D with show3d(ff), see help(show3d) \\n\n\\n\nff contains following internal elements: \\n \",ls())\n}\n\n#m2 plot output\nplot.forestFloor = function(ff,\n                            colour_by=1,\n                            col_axis = 1,\n                            plot_seq=NULL,\n                            alpha=\"auto\",\n                            limitX=FALSE,\n                            limitY=TRUE,\n                            order_by_importance=T,\n                            external.col=NULL,\n                            cropXaxes=NULL,\n                            crop_limit=4,\n                            ...)\n  {\n  \n  pars = par(no.readonly = TRUE) #save previous graphical par(emeters)\n  par(mar=c(2,2,1,1),cex=.5) #changing par, narrowing plot margins, smaller points\n  \n  #short for phys.val and feature contribution in object\n  X = ff$X\n  FCs = ff$FCmatrix\n  \n  #Auto setting transparancy variable. The more obs, the more transparrency\n  if(alpha==\"auto\") alpha = min(max(400/dim(X)[1],0.2),1)\n  \n  #If now sequnce, choosing to plot first 18 variables\n  if(is.null(plot_seq)) plot_seq = 1:min(dim(X)[2],24)\n  \n  #make catogorical features numeric, save jitter.template\n  jitter.template=rep(FALSE,dim(X)[2]) #list of what features are catagorical\n  as.numeric.factor <- function(x) {match(x,levels(x))}\n  for(i in 1:dim(X)[2]) {\n    if(is.factor(X[,i])) {\n      jitter.template[i]=T\n      this.fac=as.numeric.factor(X[,i])\n      X[,i] = this.fac\n    }\n    if(is.character(X[,i])) X[,i] = as.numeric(X[,i])\n  } \n  \n  ##get dimensions of plots\n  n.plots = min(dim(X)[2],length(plot_seq))\n  plotdims.y = min(ceiling(n.plots/3),5)\n  plotdims.x = min(3 , n.plots)\n  par(mfrow=c(plotdims.y,plotdims.x))\n  \n  ##get importance for plotting\n  imp = ff$importance     #fetch importance\n  imp.ind = ff$imp_ind    #fetch importance ranking/indices\n  \n  \n  #set default.colour\n  colours = \"black\"\n  if(!is.null(external.col)) {\n    colours = external.col\n  } else {\n    \n  #following is multiple colour rules:\n  \n  if(colour_by==\"PCA\") {\n  #make importance scaled PCA of X\n    if(col_axis==1) {\n      pca.X  = prcomp(scale(X)*t(replicate(dim(X)[1],imp)))\n    } else {\n      pca.X  = prcomp(scale(FCs)*t(replicate(dim(FCs)[1],imp)))\n    }\n      PC123 = pca.X$x[,1:3] #fetch 3 first principal components\n\n  #apply box.outliers to PCA components, to avoid extreme colour leverage of outliers\n  PC123.box = apply(PC123,2,box.outliers)\n  #change into colours, with transparancy\n  colours   = apply(PC123.box,1,function(x) rgb(x[1],x[2],x[3],alpha=alpha))\n  }\n  \n  #colour by top2 variables\n  if(colour_by==\"top2\") {\n    if(col_axis==1) {\n      sX = apply(X[,imp.ind[1:3]],2,box.outliers)\n    }else{\n      sX = apply(FCs[,imp.ind[1:3]],2,box.outliers) \n    }\n    nX = apply(sX,2, function(x) (x-min(x))/(max(x)-min(x)))\n    nX = apply(nX,2, function(x) (x+.5) / 1.5)\n    colours = apply(nX,1,function(x) rgb(x[1],x[2],.1,alpha=alpha))\n  }\n  \n  ## colour by specific variable\n  if(is.numeric(colour_by)) {\n    if(col_axis==1) {\n      sX = apply(X[,imp.ind[rep(colour_by,3)]],2,box.outliers)\n    } else {\n      sX = apply(FCs[,imp.ind[rep(colour_by,3)]],2,box.outliers)\n    }\n    \n    nX = apply(sX,2, function(x) (x-min(x))/(max(x)-min(x)))\n    colours = apply(nX,1,function(x) rgb(x[1]^3,1-x[1]^3-(1-x[3])^3,(1-x[3])^3,alpha=alpha))\n    #rainbow colouring\n    #nx = X[,imp.ind[colour_by]]\n    #colours = rainbow(length(nx),start=0.2,alpha=alpha)[match(1:length(nx),sort(nx,index.return=T)$ix)]\n  }\n  \n  }\n  \n  #Save this colouring globally, for later 3D plotting\n  if(exists(\"forestFloor_graphics.env\",env=.GlobalEnv)) {\n    assign(\"obs.indv.colours\",colours,env=forestFloor_graphics.env)\n  } else {\n    local({forestFloor_graphics.env <- new.env()},env=.GlobalEnv)\n    assign(\"obs.indv.colours\",colours,env=forestFloor_graphics.env)\n    #goto global env, make graphics.env, place colours here\n  }\n  \n  \n  \n  \n  ##plot the n.plots most important variables\n  Xsd = 0:1 #initialize Xsd\n  if(!order_by_importance) imp.ind=sort(imp.ind) #optinal removal of importance order\n  for(i in plot_seq) {\n    \n    if(i %in% cropXaxes && !is.null(cropXaxes)) {\n      limitX = T\n      Xsd = box.outliers(as.numeric(X[,imp.ind[i]],2),limit=crop_limit,normalize=F)\n    } else {\n      limitX = F\n    }\n    \n    plot(\n      data.frame( # data to plot\n        physical.value        = jitter(X[,imp.ind[i]],factor=jitter.template[imp.ind[i]]*2),\n        partial.contribution  = FCs[,imp.ind[i]]\n      ),\n      main = names(imp)[imp.ind[i]],\n      col = colours,  #colours are fetched from forestFloor_graphics.env\n      ylim = list(NULL,range(FCs))[[limitY+1]], #same Yaxis if limitY == TRUE\n      xlim = list(NULL,range(Xsd))[[limitX+1]],\n      ...\n    )\n  }\n  #print(pars$pin)\n  par(pars)\n}\n\n#m3 3d show function\nshow3d = function(ff,\n         order_by_importance=F,\n         which_matrices=c(\"X\",\"X\",\"FCmatrix\"),\n         x_cols=1,y_cols=2,z_cols=c(1:2),\n         plot.surface=T,\n         grid.lines=30,\n         k=5,\n         alpha.surf=.4,\n         alpha.obs=.4,\n         size.obs=3,\n         z_scale=.7,\n         knnBag=20,\n         bag.ratio=0.5,\n         avoidFreeType = T,\n         ...) {\n  \n  library(rgl) #import entire rgl library\n  \n  #retrieve labels for plotting\n  xyzlab = with(ff,{\n    lab=c()\n    if(!order_by_importance) imp_ind = sort(imp_ind)\n    lab$x =       names(get(which_matrices[1]))[imp_ind[x_cols]]\n    lab$y =       names(get(which_matrices[2]))[imp_ind[y_cols]]\n    lab$z =       names(get(which_matrices[3]))[imp_ind[z_cols]]\n    return(lab)\n  })\n  \n  \n  #apply funciton later requires two inputs pr axis, if one that is duplicated into two\n  cols.fix = function(i) if(length(i)<2){i=c(i,i)}else{i}\n  x_cols = cols.fix(x_cols)\n  y_cols = cols.fix(y_cols)\n  z_cols = cols.fix(z_cols)\n  \n  \n  axisval = with(ff,{\n    axisval=c()\n    if(order_by_importance) {\n      imp.ind = imp_ind\n      ind_by_imp = function(cols,imp.ind) imp.ind[cols]\n      x_cols = ind_by_imp(x_cols,imp.ind)\n      y_cols = ind_by_imp(y_cols,imp.ind)\n      z_cols = ind_by_imp(z_cols,imp.ind)\n    }\n      \n      if(!which_matrices[1]==\"FCmatrix\") {\n        axisval$x =          get(which_matrices[1])[,x_cols[1]]\n      }else{\n        axisval$x =    apply(get(which_matrices[1])[,x_cols],1,mean)\n      }\n      if(!which_matrices[2]==\"FCmatrix\") {\n        axisval$y       =    get(which_matrices[2])[,y_cols[1]]\n      }else{\n        axisval$y =    apply(get(which_matrices[2])[,y_cols],1,mean)\n      }\n      if(!which_matrices[3]==\"FCmatrix\") {\n        axisval$z          = get(which_matrices[3])[,z_cols[1]]  \n      }else{\n        axisval$z    = apply(get(which_matrices[3])[,z_cols],1,mean)\n      }\n    return(axisval)\n  })\n  \n  as.numeric.factor <- function(x) {match(x,levels(x))}\n  if(is.factor(axisval$x)) axisval$x = as.numeric.factor(axisval$x)\n  if(is.factor(axisval$y)) axisval$y = as.numeric.factor(axisval$y)\n  if(is.factor(axisval$z)) axisval$z = as.numeric.factor(axisval$z)\n  \n  # Open 3d picture,\n  rgl::open3d(...)\n\n  # Get colours\n  if(exists(\"obs.indv.colours\",env=forestFloor_graphics.env)) {\n    colpal = get(\"obs.indv.colours\",env=forestFloor_graphics.env)\n  } else {\n    colpal = \"black\"\n  }\n  \n    \n  #should surfe of data also be plotted\n  if(plot.surface) { \n    #compute grid around data\n    get.seq = function(x) seq(min(x),max(x),length.out=grid.lines)\n    XY = as.matrix(cbind(axisval$x,axisval$y),dimnames=NULL)\n    ite.val=apply(XY,2,get.seq)\n    gridXY=as.matrix(expand.grid(ite.val[,1],ite.val[,2]),dimnames=NULL) #grid coordinates\n    g.points = grid.lines^2\n#     \n#     #rescale variables to equal to achieve equal influence in kNN-model\n#     sXY = scale(XY) #scale XY\n#     sgridXY = scale.by(scale.this=gridXY,by.this=sXY) #scale grid exactly as XY\n      \n    ##bootstrap knn estimated surface, giving gaussian-isch distance weigths\n    outs=replicate(knnBag, {  #the following is replicated/performed severeal ~20 times\n      this.boot.ind = sample(dim(XY)[1]*bag.ratio,replace=T) #pick a bootstrap from samples             \n      sXY = scale(XY[this.boot.ind,])  #scale bootstrap to uni-variance\n      sgridXY = scale.by(scale.this=gridXY,by.this=sXY) #let grid be scaled as this bootstrap was scaled to sXY\n      out=FNN::knn.reg(train=sXY,\n                    test=sgridXY,\n                    y=axisval$z[this.boot.ind],\n                    k=k,\n                    algorithm=\"kd_tree\")$pred  #predict grid from bootstrap of samples\n      })\n    \n      out = apply(outs,1,mean) # collect predictions\n      \n      #\n      xlab = names(ff$X)\n    \n    \n      #plot.surface\n      rgl::persp3d(x=ite.val[,1], y=ite.val[,2], z=out,\n              xlab = xyzlab$x,    ylab = xyzlab$y,    zlab = \"feature contribution\",\n              aspect=c(1, 1, z_scale),\n              alpha=alpha.surf,col=\"#f2f2f2ff\",\n              ...)\n      rgl::points3d(axisval$x,axisval$y,axisval$z,col=colpal,size=size.obs,alpha=alpha.obs,...)    \n  \n  }else{  # plot.surface = FASLSE, then data points only\n    rgl::plot3d(axisval$x,axisval$y,axisval$z,\n                col=colpal,\n                aspect=c(1, 1, z_scale),\n                size=size.obs,\n                alpha=alpha.obs,\n                xlab = xyzlab$x,\n                ylab = xyzlab$y,\n                zlab = \"feature contribution\",\n                ...)\n  }            \n}\n\n\n#sf5 scale data and grid, to allow knn \nscale.by = function(scale.this,by.this) {\n  center = attributes(by.this)$'scaled:center'\n  scales = attributes(by.this)$'scaled:scale'\n  nvars = dim(scale.this)[2]\n  sapply(1:nvars, function(i) (scale.this[,i]-center[i])/scales[i])\n}\n\n\n\n\n#sf6  reduce outliers to within limit of 1.5 std.dev and/or output as normalized \nbox.outliers = function(x,limit=1.5,normalize=T) {\n  sx=scale(x)\n  if(limit!=FALSE) {\n    sx[ sx>limit] =  limit\n    sx[-sx>limit] = -limit\n  }\n  if(normalize) { \n    sx.span = max(sx) - min(sx)\n    sx = sx - min(sx)\n    sx = sx / sx.span\n    return(sx)\n  } else {\n    x = sx * attributes(sx)$\"scaled:scale\" + attributes(sx)$\"scaled:center\"\n    return(x)\n  }\n}\n\nforestFloor = function(rfo,X,calc_np=FALSE) { \n  \n  #check the RFobject have a inbag\n  if(is.null(rfo$inbag)) stop(\"input randomForest-object have no inbag, set keep.inbag=T,\ntry, randomForest(X,Y,keep.inbag=T) for regression where Y is numeric\nand, cinbag(X,Y,keep.inbag=T,keep.forest=T) for binary-class where Y is factor\n..cinbag is from trimTrees package...\nerror condition: if(is.null(rfo$inbag))\")\n   \n  #make node status a integer matrix\n  ns = rfo$forest$nodestatus\n  storage.mode(ns) = \"integer\"\n   \n  \n  #translate binary classification RF-object, to regression mode\n  if(rfo$type==\"classification\") {\n    if(length(levels(rfo$y))!=2) stop(\"no multiclass, must be binary classification.\n                                      error condition: if(length(levels(rfo$y))!=2\")\n    print(\"RF is classification, converting factors/categories to numeric 0 an 1\")\n    Y = as.numeric((rfo$y))-1\n    cat(\" defining\",levels(rfo$y)[1],\" as 0\\n defining\",levels(rfo$y)[2],\"as 1\")\n    rfo$forest$leftDaughter  = rfo$forest$treemap[,1,] #translate daughter representation to regression mode\n    rfo$forest$rightDaughter = rfo$forest$treemap[,2,] \n    ns[ns==1] = -3  ##translate nodestatus representation to regression mode\n    if(is.null(\"rfo$inbagCount\")) stop(\"classification topology not supported with randomForest() {randomForest}\nGrow forest with cinbag::trimTrees instead of randomForest(). The two\nfunctions are identical, except cinbag() entails a more detailed inbag record,\nwhich is needed to estimate binary node probabilities.\nerror condition:  if(is.null('rfo$inbagCount'))\")\n    \n    if(!calc_np) stop(\"node predictions must be re-calculated for random forest of type classification, set calc_np=T)\nerror conditions: if(!calc_np && rfo$type='classification')\")\n    \n    inbag = rfo$inbagCount\n    } else {\n    Y=rfo$y\n    inbag = rfo$inbag\n  }\n\n\n  #preparing data, indice-correction could be moved to C++\n  #a - This should be fethed from RF-object, flat interface\n  ld = rfo$forest$leftDaughter-1 #indice correction, first element is 0 in C++ and 1 in R.\n  storage.mode(ld) = \"integer\"\n  rd = rfo$forest$rightDaughter-1\n  storage.mode(rd) = \"integer\"\n  bv = rfo$forest$bestvar-1\n  storage.mode(bv) = \"integer\"\n  np = rfo$forest$nodepred\n  storage.mode(np) = \"double\"\n  bs = rfo$forest$xbestsplit\n  storage.mode(bs) = \"double\"\n  ib = inbag\n  storage.mode(ib) = \"integer\"\n  Yd = as.numeric(Y)\n  storage.mode(Yd) = \"double\"\n  ot  = rfo$oob.times\n  storage.mode(ot) = \"integer\"\n \n \n  ##recording types of variables\n  xlevels = unlist(lapply(rfo$forest$xlevels,length),use.names=F)\n  xl = xlevels\n  storage.mode(xl) = \"integer\"\n  varsToBeConverted = xlevels>1\n\n  ##Converting X to Xd, all factors change to level numbers\n  Xd=X\n  for(i in 1:dim(Xd)[2]) {\n    if(varsToBeConverted[i]) {\n      Xd[,i] = as.numeric(Xd[,i])-1  \n    }\n  }  \n  Xd=as.matrix(Xd)\n  storage.mode(Xd) = \"double\"\n  \n  #outout variable\n  localIncrements = Xd*0\n  storage.mode(localIncrements) = \"double\"\n  \n  #should activities of nodes be reestimated(true) or reused from randomForest object(false)\n  calculate_node_pred=calc_np\n    \n  # C++ function, recursively finding increments of all nodes of all trees\n  # where OOB samples are present. vars, obs and ntree is \"passed by number\"\n  # Anything else is passed by reference. Found increments are imediately\n  # summed to localIncrements matrix.\n  recTree(\n    #passed by number\n    vars=dim(X)[2], \n    obs=dim(X)[1],             \n    ntree=rfo$ntree,\n    calculate_node_pred=calculate_node_pred,\n    #passed by reference\n    X=Xd,  #training data, double matrix [obs,vars] \n    Y=Yd,\n    leftDaughter = ld,  #row indices of left subnodes, integer matrix [nrnodes,ntree] \n    rightDaughter = rd, #...\n    nodestatus = ns,    #weather node is terminal or not,      \n    xbestsplit = bs,          \n    nodepred = np,          \n    bestvar = bv,\n    inbag = ib,\n    varLevels = xl,\n    ot,  #oob.times\n    localIncrements = localIncrements #output is written directly to localIncrements from C++\n  )\n  \n  \n  \n#writing out list\n  imp = as.matrix(rfo$importance)[,1]\n  out = list(X=X,Y=Y,\n             importance = imp,\n             imp_ind = sort(imp,decreasing=T,index.return=T)$ix,\n             FCmatrix = localIncrements\n  )\n  class(out) = \"forestFloor\"\n  return(out)\n}",
    "created" : 1418485620292.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "210744636",
    "id" : "E7DFF3DF",
    "lastKnownWriteTime" : 1420284168,
    "path" : "~/Documents/PHD/Rlocal/forestFloor/R/forestFloor_source.R",
    "project_path" : "R/forestFloor_source.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}