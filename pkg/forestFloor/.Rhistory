wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(points.rgl.args,wrapper_arg)
plot3d_mod = plot3d
do.call("plot3d_mod",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
current_arg = surf.rgl.args
calling_arg = append.overwrite.alists(current_arg,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
show3d_new(ff,surf.rgl.args=list(k=3))
show3d_new = function(ff,         #"forestFloor" class object
Xi  = 1:2,  # indices of feature columns
FCi = 1:2,  # indices of feature contributions columns
col = "#12345678",     #points colour or colour palette
sortByImportance = T,  #should indices count 'variable importance' order or matrix/data.frame order
surface=T,
combineFC = sum,
zoom=1.2,
grid.lines=30,
limit=3,
kknnGrid.args = alist(),
plot.rgl.args = alist(),
surf.rgl.args = alist()
) {
if(class(ff)!="forestFloor") stop("ff, must be of class forestFloor")
if(length(Xi)!=2) {
warning("Xi should be of length 2, if 1 first elements is used twice, if >2 only two first elements is used")
if(length(Xi) > 2) Xi=Xi[1:2] else Xi = Xi[c(1,1)]
}
if(!all(Xi %in% 1:dim(ff$X)[2]))   stop( "input  Xi points to columns indices out of range of feature matrix ff$X")
if(!all(FCi %in% 1:dim(ff$FCmatrix)[2]) && length(FCi)>0) stop("input FCi points to columns indices out of range of feature matrix ff$X")
#fetch selected coloums from object
X = ff$X[,Xi]
FC = ff$FCmatrix[,FCi]
#define xy coordinates from features and z from feature contributions
xaxis = X[,1]
yaxis = X[,2]
if(length(FCi)==1) zaxis = FC else zaxis = apply(FC,1,combineFC) #if multiple FCis these will summed to one value.
#fixing categorical features
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(xaxis)) xaxis = as.numeric.factor(xaxis)
if(is.factor(yaxis)) yaxis = as.numeric.factor(yaxis)
if(is.factor(zaxis)) zaxis = as.numeric.factor(zaxis)
#compute grid
grid = convolute_grid(ff, Xvars=Xi, FCvars=FCi, limit=limit, grid=grid.lines,
zoom=zoom,  userArgs.kknn = kknnGrid.args)
#plotting points
#merge current/user, wrapper arguments for plot3d in proritized order
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(points.rgl.args,wrapper_arg)
do.call("plot3d",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
current_arg = surf.rgl.args
calling_arg = append.overwrite.alists(current_arg,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
show3d_new(ff,surf.rgl.args=list(k=3))
#input an alist and by this function the wrapper will append new args and overwrite conflicting arguments.
#one set of args either user or defaults are set as master
append.overwrite.alists= function(masterArgs,slaveArgs) {
slaveArgs.to.overwrite = names(slaveArgs) %in% names(masterArgs)
for(i in which(slaveArgs.to.overwrite))  slaveArgs[i] = masterArgs[match(names(slaveArgs[i]),names(masterArgs))]
masterArgs.to.append = !(names(masterArgs) %in% names(slaveArgs))
c(slaveArgs,masterArgs[masterArgs.to.append])
}
show3d_new(ff,surf.rgl.args=list(k=3))
show3d_new = function(ff,         #"forestFloor" class object
Xi  = 1:2,  # indices of feature columns
FCi = 1:2,  # indices of feature contributions columns
col = "#12345678",     #points colour or colour palette
sortByImportance = T,  #should indices count 'variable importance' order or matrix/data.frame order
surface=T,
combineFC = sum,
zoom=1.2,
grid.lines=30,
limit=3,
kknnGrid.args = alist(),
plot.rgl.args = alist(),
surf.rgl.args = alist()
) {
if(class(ff)!="forestFloor") stop("ff, must be of class forestFloor")
if(length(Xi)!=2) {
warning("Xi should be of length 2, if 1 first elements is used twice, if >2 only two first elements is used")
if(length(Xi) > 2) Xi=Xi[1:2] else Xi = Xi[c(1,1)]
}
if(!all(Xi %in% 1:dim(ff$X)[2]))   stop( "input  Xi points to columns indices out of range of feature matrix ff$X")
if(!all(FCi %in% 1:dim(ff$FCmatrix)[2]) && length(FCi)>0) stop("input FCi points to columns indices out of range of feature matrix ff$X")
#fetch selected coloums from object
X = ff$X[,Xi]
FC = ff$FCmatrix[,FCi]
#define xy coordinates from features and z from feature contributions
xaxis = X[,1]
yaxis = X[,2]
if(length(FCi)==1) zaxis = FC else zaxis = apply(FC,1,combineFC) #if multiple FCis these will summed to one value.
#fixing categorical features
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(xaxis)) xaxis = as.numeric.factor(xaxis)
if(is.factor(yaxis)) yaxis = as.numeric.factor(yaxis)
if(is.factor(zaxis)) zaxis = as.numeric.factor(zaxis)
#compute grid
grid = convolute_grid(ff, Xvars=Xi, FCvars=FCi, limit=limit, grid=grid.lines,
zoom=zoom,  userArgs.kknn = kknnGrid.args)
#plotting points
#merge current/user, wrapper arguments for plot3d in proritized order
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(plot.rgl.args,wrapper_arg)
do.call("plot3d",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
calling_arg = append.overwrite.alists(surf.rgl.args,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
show3d_new(ff,surf.rgl.args=list(k=3))
show3d_new(ff,surf.rgl.args=list(k=90))
library(forestFloor)
#simulate data
obs=5000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.2 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest(X,Y,keep.inbag = TRUE,sampsize=1500,ntree=500)
#compute topology
ff = forestFloor(rfo,X)
#sf8 neat function to help increase adaptability of wrappers, default args defined by wrapper. User can
#input an alist and by this function the wrapper will append new args and overwrite conflicting arguments.
#one set of args either user or defaults are set as master
append.overwrite.alists= function(masterArgs,slaveArgs) {
slaveArgs.to.overwrite = names(slaveArgs) %in% names(masterArgs)
for(i in which(slaveArgs.to.overwrite))  slaveArgs[i] = masterArgs[match(names(slaveArgs[i]),names(masterArgs))]
masterArgs.to.append = !(names(masterArgs) %in% names(slaveArgs))
c(slaveArgs,masterArgs[masterArgs.to.append])
}
#f1a 3d show function
show3d_new = function(ff,         #"forestFloor" class object
Xi  = 1:2,  # indices of feature columns
FCi = 1:2,  # indices of feature contributions columns
col = "#12345678",     #points colour or colour palette
sortByImportance = T,  #should indices count 'variable importance' order or matrix/data.frame order
surface=T,
combineFC = sum,
zoom=1.2,
grid.lines=30,
limit=3,
kknnGrid.args = alist(),
plot.rgl.args = alist(),
surf.rgl.args = alist()
) {
if(class(ff)!="forestFloor") stop("ff, must be of class forestFloor")
if(length(Xi)!=2) {
warning("Xi should be of length 2, if 1 first elements is used twice, if >2 only two first elements is used")
if(length(Xi) > 2) Xi=Xi[1:2] else Xi = Xi[c(1,1)]
}
if(!all(Xi %in% 1:dim(ff$X)[2]))   stop( "input  Xi points to columns indices out of range of feature matrix ff$X")
if(!all(FCi %in% 1:dim(ff$FCmatrix)[2]) && length(FCi)>0) stop("input FCi points to columns indices out of range of feature matrix ff$X")
#fetch selected coloums from object
X = ff$X[,Xi]
FC = ff$FCmatrix[,FCi]
#define xy coordinates from features and z from feature contributions
xaxis = X[,1]
yaxis = X[,2]
if(length(FCi)==1) zaxis = FC else zaxis = apply(FC,1,combineFC) #if multiple FCis these will summed to one value.
#fixing categorical features
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(xaxis)) xaxis = as.numeric.factor(xaxis)
if(is.factor(yaxis)) yaxis = as.numeric.factor(yaxis)
if(is.factor(zaxis)) zaxis = as.numeric.factor(zaxis)
#compute grid
grid = convolute_grid(ff, Xvars=Xi, FCvars=FCi, limit=limit, grid=grid.lines,
zoom=zoom,  userArgs.kknn = kknnGrid.args)
#plotting points
#merge current/user, wrapper arguments for plot3d in proritized order
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(plot.rgl.args,wrapper_arg)
do.call("plot3d",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
calling_arg = append.overwrite.alists(surf.rgl.args,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
show3d_new(ff,kknnGrid.args=list(k=90))
show3d_new(ff,kknnGrid.args=list(k=3))
?alist
#f1a 3d show function
show3d_new = function(ff,         #"forestFloor" class object
Xi  = 1:2,  # indices of feature columns
FCi = 1:2,  # indices of feature contributions columns
col = "#12345678",     #points colour or colour palette, can also be passed as promise in plot.rgl.args
sortByImportance = T,  #should indices count 'variable importance' order or matrix/data.frame order
surface=T,    #should a surface be plotted also
combineFC = sum,  #how should feature contributions be combined
zoom=1.2,       #grid can be expanded in all directions by a factor ,zoom
grid.lines=30,  #how many grid lines should be used
limit=3, #grid does not concider outliers, outside limit of e.g. 3 sd deviations
kknnGrid.args = alist(),  #any possiple argument to kknn package, overwrites this wrapper
plot.rgl.args = alist(),  #same to rgl::plot3d, overrides this wrapper, defines plotting space
surf.rgl.args = alist()   #same to rgl::persp3d, overrides this wraper, added to plot3d
) {
if(class(ff)!="forestFloor") stop("ff, must be of class forestFloor")
if(length(Xi)!=2) {
warning("Xi should be of length 2, if 1 first elements is used twice, if >2 only two first elements is used")
if(length(Xi) > 2) Xi=Xi[1:2] else Xi = Xi[c(1,1)]
}
if(!all(Xi %in% 1:dim(ff$X)[2]))   stop( "input  Xi points to columns indices out of range of feature matrix ff$X")
if(!all(FCi %in% 1:dim(ff$FCmatrix)[2]) && length(FCi)>0) stop("input FCi points to columns indices out of range of feature matrix ff$X")
#fetch selected coloums from object
X = ff$X[,Xi]
FC = ff$FCmatrix[,FCi]
#define xy coordinates from features and z from feature contributions
xaxis = X[,1]
yaxis = X[,2]
if(length(FCi)==1) zaxis = FC else zaxis = apply(FC,1,combineFC) #if multiple FCis these will summed to one value.
#fixing categorical features
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(xaxis)) xaxis = as.numeric.factor(xaxis)
if(is.factor(yaxis)) yaxis = as.numeric.factor(yaxis)
if(is.factor(zaxis)) zaxis = as.numeric.factor(zaxis)
#compute grid
grid = convolute_grid(ff, Xvars=Xi, FCvars=FCi, limit=limit, grid=grid.lines,
zoom=zoom,  userArgs.kknn = kknnGrid.args)
#plotting points
#merge current/user, wrapper arguments for plot3d in proritized order
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(plot.rgl.args,wrapper_arg)
do.call("plot3d",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
calling_arg = append.overwrite.alists(surf.rgl.args,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
if(is.null(FCi)) FCi=Xi
show3d_new = function(ff,         #"forestFloor" class object
Xi  = 1:2,  # indices of feature columns
FCi = NULL,  # indices of feature contributions columns
col = "#12345678",     #points colour or colour palette, can also be passed as promise in plot.rgl.args
sortByImportance = T,  #should indices count 'variable importance' order or matrix/data.frame order
surface=T,    #should a surface be plotted also
combineFC = sum,  #how should feature contributions be combined
zoom=1.2,       #grid can be expanded in all directions by a factor ,zoom
grid.lines=30,  #how many grid lines should be used
limit=3, #grid does not concider outliers, outside limit of e.g. 3 sd deviations
kknnGrid.args = alist(),  #any possiple argument to kknn package, overwrites this wrapper
plot.rgl.args = alist(),  #same to rgl::plot3d, overrides this wrapper, defines plotting space
surf.rgl.args = alist()   #same to rgl::persp3d, overrides this wraper, added to plot3d
) {
if(class(ff)!="forestFloor") stop("ff, must be of class forestFloor")
if(length(Xi)!=2) {
warning("Xi should be of length 2, if 1 first elements is used twice, if >2 only two first elements is used")
if(length(Xi) > 2) Xi=Xi[1:2] else Xi = Xi[c(1,1)]
}
if(!all(Xi %in% 1:dim(ff$X)[2]))   stop( "input  Xi points to columns indices out of range of feature matrix ff$X")
if(is.null(FCi)) FCi=Xi
if(!all(FCi %in% 1:dim(ff$FCmatrix)[2]) && length(FCi)>0) stop("input FCi points to columns indices out of range of feature matrix ff$X")
#fetch selected coloums from object
X = ff$X[,Xi]
FC = ff$FCmatrix[,FCi]
#define xy coordinates from features and z from feature contributions
xaxis = X[,1]
yaxis = X[,2]
if(length(FCi)==1) zaxis = FC else zaxis = apply(FC,1,combineFC) #if multiple FCis these will summed to one value.
#fixing categorical features
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(xaxis)) xaxis = as.numeric.factor(xaxis)
if(is.factor(yaxis)) yaxis = as.numeric.factor(yaxis)
if(is.factor(zaxis)) zaxis = as.numeric.factor(zaxis)
#compute grid
grid = convolute_grid(ff, Xvars=Xi, FCvars=FCi, limit=limit, grid=grid.lines,
zoom=zoom,  userArgs.kknn = kknnGrid.args)
#plotting points
#merge current/user, wrapper arguments for plot3d in proritized order
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
calling_arg = append.overwrite.alists(plot.rgl.args,wrapper_arg)
do.call("plot3d",args=calling_arg)
#plotting surface
#merge arguments again
if(surface) {
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4) #args defined in this wrapper function
calling_arg = append.overwrite.alists(surf.rgl.args,wrapper_arg)
do.call("persp3d",args=calling_arg)
}
}
show3d_new(ff,3:4,kknnGrid.args=list(k=3))
show3d_new(ff,3:4)
show3d(ff,3:4)
args(show3d(ff,3:4))
args(show3d)
show3d(ff)
plot(ff)
show3d(ff)
show3d(ff,x_cols=1,y_cols=2)
show3d(ff,x_cols=3,y_cols=4)
show3d(ff,x_cols=3,y_cols=4,z_cols=3:4)
open3d()
show3d_new(ff,3:4)
show3d_new(ff,3:4,kknnGrid.args=list(k=5))
show3d_new(ff,3:4,kknnGrid.args=list(k=5,kernel="ep"))
show3d_new(ff,3:4,kknnGrid.args=list(kernel="ep"))
show3d_new(ff,3:4,kknnGrid.args=list(kernel="ep",k=60))
names(ff)
wrapper_arg = alist(x=unique(grid[,2]),y=unique(grid[,3]),z=grid[,1],add=TRUE,alpha=0.4)
wrapper_arg = alist(x=xaxis, y=yaxis, z=zaxis, col=col,
xlab=names(X)[1],ylab=names(X)[2],zlab=paste(names(X),collapse=" - "),
alpha=.4,size=3,scale=.7,avoidFreeType = T,add=FALSE)
?kknn
library(forestFloor)
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
#Non interacting functions are well displayed, whereas X3 and X4 are not
#by applying different colourgradient, interactions reveal themself
plot(ff,plot_seq=NULL,colour_by=3,col_axis=1)
#in 3D the interaction between X3 and X reveals itself completely
show3d_new(ff,Xi=3:4)
hsv
box.outliers(ff$X[,3:4])
colours = hsv(box.outliers(ff$X[,3:4])*0.7,0.9,0.2)
colours = hsv(box.outliers(ff$X[,3])*0.7,0.9,0.2)
colours
colours = hsv(box.outliers(ff$X[,3])*0.7,0.9,0.2,alpha=0.5)
show3d_new(ff,Xi=3:4,col=hsv())
show3d_new(ff,Xi=3:4,col=colours)
colours = hsv(box.outliers(ff$X[,3])*0.7,0.9,0.5,alpha=0.5)
show3d_new(ff,Xi=3:4,col=colours)
colours = hsv(box.outliers(ff$X[,3])*0.7,1,1,alpha=0.5)
show3d_new(ff,Xi=3:4,col=colours)
colours = hsv(box.outliers(ff$X[,3]),1,1,alpha=0.5) #defining colour gradient along X3
show3d_new(ff,Xi=3:4,col=colours)
colours = hsv(box.outliers(ff$X[,3])*0.7,1,1,alpha=0.5) #defining colour gradient along X3
show3d_new(ff,Xi=3:4,col=colours)
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
#Non interacting functions are well displayed, whereas X3 and X4 are not
#by applying different colourgradient, interactions reveal themself
plot(ff,plot_seq=NULL,colour_by=3,col_axis=1)
#in 3D the interaction between X3 and X reveals itself completely
colours = hsv(box.outliers(ff$X[,3])*0.7,1,1,alpha=0.5) #defining colour gradient along X3
show3d_new(ff,Xi=3:4,col=colours)
library(forestFloor)
library(randomForest)
library(ffData)
library(rfFC)
data(abalone)
names(abalone)
X=abalone[,-9]
Y=abalone[, 9]
rfo=randomForest(X,Y,keep.inbag=T,ntree=500,mtry=3,sampsize=500,importance=T)
ff = forestFloor(rfo,X)
plot(ff,colour_by="PCA",cropXaxes=c(2,4:5),crop_limit=3.8)
plot(ff,colour_by="PCA",cropXaxes=c(2,4:5),crop_limit=3.8)
rm(list=ls())
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
rfo
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
par(mar)
par()$mar
par()$mfrow
rm(list=ls())
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
rm(list=ls())
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
library(forestFloor)
rm(list=ls())
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
print(pars$pin)
pars = par(no.readonly = TRUE) #save previous graphical par(emeters)
par(pars)
print(pars$pin)
pars = par(no.readonly = TRUE)
pars
pars$pin
pars$pin
exists(pars$pin)
exists
pars$pin
with(pars,exists(pin))
exists("pars$pin")
with(pars,exists("pin")
)
if(with(pars,exists("pin"))) rm(pars$pin
)
if(with(pars,exists("pin"))) rm("pars$pin")
pars$pin
pars = with(pars,if(exists("pin")) {
rm(pin)
return(mget())
})
pars = with(pars,if(exists("pin")) {
rm(pin)
return(mget(ls()))
})
par(pars)
library(forestFloor)
rm(list=ls())
#simulate data
obs=1000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + sin(X2*pi) + 2 * X3 * X4 + 0.5 * rnorm(obs))
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1)
plot(ff,plot_seq=NULL,colour_by=3,col_axis=1)
#in 3D the interaction between X3 and X reveals itself completely
colours = hsv(box.outliers(ff$X[,3])*0.7,1,1,alpha=0.5) #defining colour gradient along X3
show3d_new(ff,Xi=3:4,col=colours)
show3d_new(ff,Xi=3:4,col=colours)
library(forestFloor)
show3d_new(ff,Xi=3:4,col=colours)
paste(names(X[,FCi]),collapse=" - ")
library(forestFloor)
show3d_new(ff,Xi=3:4,col=colours)
library(forestFloor)
