if(!which_matrices[1]=="FCmatrix") {
axisval$x =          get(which_matrices[1])[,x_cols[1]]
}else{
axisval$x =    apply(get(which_matrices[1])[,x_cols],1,mean)
}
if(!which_matrices[2]=="FCmatrix") {
axisval$y       =    get(which_matrices[2])[,y_cols[1]]
}else{
axisval$y =    apply(get(which_matrices[2])[,y_cols],1,mean)
}
if(!which_matrices[3]=="FCmatrix") {
axisval$z          = get(which_matrices[3])[,z_cols[1]]
}else{
axisval$z    = apply(get(which_matrices[3])[,z_cols],1,mean)
}
return(axisval)
})
as.numeric.factor <- function(x) {match(x,levels(x))}
if(is.factor(axisval$x)) axisval$x = as.numeric.factor(axisval$x)
if(is.factor(axisval$y)) axisval$y = as.numeric.factor(axisval$y)
if(is.factor(axisval$z)) axisval$z = as.numeric.factor(axisval$z)
# Open 3d picture,
open3d(...)
# Get colours
if(exists("obs.indv.colours",envir=forestFloor_graphics.env)) {
colpal = get("obs.indv.colours",envir=forestFloor_graphics.env)
} else {
colpal = "black"
}
#should surfe of data also be plotted
if(plot.surface) {
#compute grid around data
get.seq = function(x) seq(min(x),max(x),length.out=grid.lines)
XY = as.matrix(cbind(axisval$x,axisval$y),dimnames=NULL)
ite.val=apply(XY,2,get.seq)
gridXY=as.matrix(expand.grid(ite.val[,1],ite.val[,2]),dimnames=NULL) #grid coordinates
g.points = grid.lines^2
#
#     #rescale variables to equal to achieve equal influence in kNN-model
#     sXY = scale(XY) #scale XY
#     sgridXY = scale.by(scale.this=gridXY,by.this=sXY) #scale grid exactly as XY
##bootstrap knn estimated surface, giving gaussian-isch distance weigths
#
xlab = names(x$X)
#plot.surface
persp3d(x=ite.val[,1], y=ite.val[,2], z=out,
xlab = xyzlab$x,    ylab = xyzlab$y,    zlab = "feature contribution",
aspect=c(1, 1, z_scale),
alpha=alpha.surf,col="#f2f2f2ff",
...)
points3d(axisval$x,axisval$y,axisval$z,col=colpal,size=size.obs,alpha=alpha.obs,...)
}else{  # plot.surface = FASLSE, then data points only
plot3d(axisval$x,axisval$y,axisval$z,
col=colpal,
aspect=c(1, 1, z_scale),
size=size.obs,
alpha=alpha.obs,
xlab = xyzlab$x,
ylab = xyzlab$y,
zlab = "feature contribution",
...)
}
}
#sf5 scale data and grid, to allow knn
scale.by = function(scale.this,by.this) {
center = attributes(by.this)$'scaled:center'
scales = attributes(by.this)$'scaled:scale'
nvars = dim(scale.this)[2]
sapply(1:nvars, function(i) (scale.this[,i]-center[i])/scales[i])
}
#sf6  reduce outliers to within limit of 1.5 std.dev and/or output as normalized
box.outliers = function(x,limit=1.5,normalize=T) {
sx=scale(x)
if(limit!=FALSE) {
sx[ sx>limit] =  limit
sx[-sx>limit] = -limit
}
if(normalize) {
sx.span = max(sx) - min(sx)
sx = sx - min(sx)
sx = sx / sx.span
return(sx)
} else {
x = sx * attributes(sx)$"scaled:scale" + attributes(sx)$"scaled:center"
return(x)
}
}
#sf7 estimate surface with kNNbag, depends on "sf5 - scale.by"
kNN.surf = function(knnBag,
XY,
gridXY,
k,
y,
bag.ratio=.8,
replace=T) {
outs=replicate(knnBag, {  #the following is replicated/performed severeal ~20 times
this.boot.ind = sample(dim(XY)[1]*bag.ratio,replace=T) #pick a bootstrap from samples
sXY = scale(XY[this.boot.ind,])  #scale bootstrap to uni-variance
sgridXY = scale.by(scale.this=gridXY,by.this=sXY) #let grid be scaled as this bootstrap was scaled to sXY
out=knn.reg(train=sXY,
test=sgridXY,
y=y[this.boot.ind],
k=k,
algorithm="kd_tree")$pred  #predict grid from bootstrap of samples
})
out = apply(outs,1,mean) # collect predictions
return(out)
}
forestFloor = function(rfo,X,calc_np=FALSE) {
#check the RFobject have a inbag
if(is.null(rfo$inbag)) stop("input randomForest-object have no inbag, set keep.inbag=T,
try, randomForest(X,Y,keep.inbag=T) for regression where Y is numeric
and, cinbag(X,Y,keep.inbag=T,keep.forest=T) for binary-class where Y is factor
..cinbag is from trimTrees package...
error condition: if(is.null(rfo$inbag))")
#make node status a integer matrix
ns = rfo$forest$nodestatus
storage.mode(ns) = "integer"
#translate binary classification RF-object, to regression mode
if(rfo$type=="classification") {
if(length(levels(rfo$y))!=2) stop("no multiclass, must be binary classification.
error condition: if(length(levels(rfo$y))!=2")
print("RF is classification, converting factors/categories to numeric 0 an 1")
Y = as.numeric((rfo$y))-1
cat(" defining",levels(rfo$y)[1]," as 0\n defining",levels(rfo$y)[2],"as 1")
rfo$forest$leftDaughter  = rfo$forest$treemap[,1,] #translate daughter representation to regression mode
rfo$forest$rightDaughter = rfo$forest$treemap[,2,]
ns[ns==1] = -3  ##translate nodestatus representation to regression mode
if(is.null("rfo$inbagCount")) stop("classification topology not supported with randomForest() {randomForest}
Grow forest with cinbag::trimTrees instead of randomForest(). The two
functions are identical, except cinbag() entails a more detailed inbag record,
which is needed to estimate binary node probabilities.
error condition:  if(is.null('rfo$inbagCount'))")
if(!calc_np) stop("node predictions must be re-calculated for random forest of type classification, set calc_np=T)
error conditions: if(!calc_np && rfo$type='classification')")
inbag = rfo$inbagCount
} else {
Y=rfo$y
inbag = rfo$inbag
}
#preparing data, indice-correction could be moved to C++
#a - This should be fethed from RF-object, flat interface
ld = rfo$forest$leftDaughter-1 #indice correction, first element is 0 in C++ and 1 in R.
storage.mode(ld) = "integer"
rd = rfo$forest$rightDaughter-1
storage.mode(rd) = "integer"
bv = rfo$forest$bestvar-1
storage.mode(bv) = "integer"
np = rfo$forest$nodepred
storage.mode(np) = "double"
bs = rfo$forest$xbestsplit
storage.mode(bs) = "double"
ib = inbag
storage.mode(ib) = "integer"
Yd = as.numeric(Y)
storage.mode(Yd) = "double"
ot  = rfo$oob.times
storage.mode(ot) = "integer"
##recording types of variables
xlevels = unlist(lapply(rfo$forest$xlevels,length),use.names=F)
xl = xlevels
storage.mode(xl) = "integer"
varsToBeConverted = xlevels>1
##Converting X to Xd, all factors change to level numbers
Xd=X
for(i in 1:dim(Xd)[2]) {
if(varsToBeConverted[i]) {
Xd[,i] = as.numeric(Xd[,i])-1
}
}
Xd=as.matrix(Xd)
storage.mode(Xd) = "double"
#outout variable
localIncrements = Xd*0
storage.mode(localIncrements) = "double"
#should activities of nodes be reestimated(true) or reused from randomForest object(false)
calculate_node_pred=calc_np
# C++ function, recursively finding increments of all nodes of all trees
# where OOB samples are present. vars, obs and ntree is "passed by number"
# Anything else is passed by reference. Found increments are imediately
# summed to localIncrements matrix.
recTree(
#passed by number
vars=dim(X)[2],
obs=dim(X)[1],
ntree=rfo$ntree,
calculate_node_pred=calculate_node_pred,
#passed by reference
X=Xd,  #training data, double matrix [obs,vars]
Y=Yd,
leftDaughter = ld,  #row indices of left subnodes, integer matrix [nrnodes,ntree]
rightDaughter = rd, #...
nodestatus = ns,    #weather node is terminal or not,
xbestsplit = bs,
nodepred = np,
bestvar = bv,
inbag = ib,
varLevels = xl,
ot,  #oob.times
localIncrements = localIncrements #output is written directly to localIncrements from C++
)
#writing out list
imp = as.matrix(rfo$importance)[,1]
out = list(X=X,Y=Y,
importance = imp,
imp_ind = sort(imp,decreasing=T,index.return=T)$ix,
FCmatrix = localIncrements
)
class(out) = "forestFloor"
return(out)
}
library(randomForest)
obs=5000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + 2*sin(X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,sampsize=800)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
par(mfrow=c(2,3),mar=c(2,2,1,1))
for(i in 1:vars) vec.plot(X,rfo,i,zoom=1.5,limitY=T)
#Non interacting functions are well displayed, whereas X3 and X4 are not
#by applying different colourgradient, interactions reveal themself
plot(ff,plot_seq=NULL,colour_by=2,col_axis=1)
kNN.surf
args(kNN.surf)
args(show3d)
source('~/Documents/PHD/Rlocal/ForstArticle/forestFloor_source_newShow.R')
show3d(ff)
library(rgl)
show3d(ff)
args(show3d)
source('~/Documents/PHD/Rlocal/ForstArticle/forestFloor_source_newShow.R')
show3d(ff)
library(FNN)
show3d(ff)
show3d(ff,k=100)
show3d(ff,k=100,grid.lines=80)
show3d(ff,k=100,grid.lines=50)
source('~/Documents/PHD/Rlocal/ForstArticle/forestFloor_source_newShow.R')
show3d(ff,k=100,grid.lines=10)
all.that = show3d(ff,k=100,grid.lines=10)
ls(all.that)
with(all.that,ls())
length(all.that)
length(all.that[[1]])
ls(all.that[[1]])
?mget
source('~/Documents/PHD/Rlocal/ForstArticle/forestFloor_source_newShow.R')
all.that = show3d(ff,k=100,grid.lines=10)
ls(all.that)
all.that$out2
plot(all.that$out2,axisval$z)
plot(all.that$out2,all.that$axisval$z)
plot(all.that$out2,all.that$axisval$z,col=with(forestFloor_graphics.env,get(ls())))
plot(all.that$axisval$x,all.that$out2-all.that$axisval$z,col=with(forestFloor_graphics.env,get(ls())))
plot(all.that$axisval$y,all.that$out2-all.that$axisval$z,col=with(forestFloor_graphics.env,get(ls())))
(all.that$out2-all.that$axisval$z)^2
sum((all.that$out2-all.that$axisval$z)^2)
sum((0.00001+all.that$out2-all.that$axisval$z)^2)
sum((all.that$out2-all.that$axisval$z)^2)
rnorm(obs)
X = data.frame(replicate(vars,rnorm(obs)))
X
Y = with(X, X1^2 + 2*sin(X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,sampsize=800)
var(Y)/var(Y+Yerror)
rfo
all.that=show3d(ff,k=100,grid.lines=10)
sum((all.that$out2-all.that$axisval$z)^2)
sum((axisval$z-out2)^2)
SSmodelSurf = sum((out2)^2)
Q2 = SSmodelSurf / (SSmodelSurf + SSerrorSurf)
source('~/Documents/PHD/Rlocal/ForstArticle/forestFloor_source_newShow.R')
show3d(ff,k=100,grid.lines=10)
show3d(ff,k=10,grid.lines=10)
show3d(ff,k=10,grid.lines=30)
show3d(ff,x_cols=3,k=10,grid.lines=30)
?plot3d
show3d(ff,x_cols=3,k=10,grid.lines=30)
spin3d()
spin3d
spin3d()
open3d()
plot3d(oh3d(col = "lightblue", alpha = 0.5))
if (!rgl.useNULL())
play3d(spin3d(axis = c(1, 0, 0), rpm = 30), duration = 2)
# Show spinning sprites, and rotate the whole view
open3d()
spriteid <- NULL
spin1 <- spin3d(rpm = 4.5 ) # the scene spinner
spin2 <- spin3d(rpm = 9 ) # the sprite spinner
f <- function(time) {
par3d(skipRedraw = TRUE) # stops intermediate redraws
on.exit(par3d(skipRedraw = FALSE)) # redraw at the end
rgl.pop(id = spriteid) # delete the old sprite
cubeid <- shade3d(cube3d(), col = "red")
spriteid <<- sprites3d(0:1, 0:1, 0:1, shape = cubeid,
userMatrix = spin2(time,
base = spin1(time)$userMatrix)$userMatrix)
spin1(time)
}
if (!rgl.useNULL())
play3d(f, duration = 2)
play3d(f, duration = 20)
play3d(f, duration = 20)
play3d(f, duration = 20)
play3d(f, duration = 20)
# #debugging break
plot3d(rnorm(100), rnorm(100), rnorm(100), type = "s", col = "red")
# This writes a copy into temporary directory 'webGL', and then displays it
filename <- writeWebGL(dir = file.path(tempdir(), "webGL"),
width = 500)
browseURL(paste0("file://", filename))
filename <- writeWebGL(dir = file.path(tempdir(), "webGL"),
width = 500)
browseURL(paste0("file://", filename))
rm(list=ls())
library(forestFloor)
vec.plot = function(X,model,i.var,grid.lines=100,VEC.function=mean,zoom=1,limitY=F,forestFloor.col=T) {
#compute grid range
d = length(i.var)
scales = lapply(i.var, function(i) {
rXi = range(X[,i])
span = abs(rXi[2]-rXi[1])*zoom/2
center = mean(rXi)
seq(center-span,center+span,length.out=grid.lines)
})
#expand grid range to a n-dimensional VEC-space and predict by model
anchor.points = as.matrix(expand.grid(scales),dimnames=NULL)
Xgeneralized=apply(X,2,VEC.function)
Xtest.vec = data.frame(t(replicate(dim(anchor.points)[1],Xgeneralized)))
Xtest.vec[,i.var] = anchor.points
yhat.vec = predict(model,Xtest.vec)
#add observations to VEC-space
values.to.plot=X[,i.var]
Xmean=apply(X,2,VEC.function)
Xtest.obs = data.frame(t(replicate(dim(X)[1],Xgeneralized)))
Xtest.obs[,i.var] = values.to.plot
yhat.obs =  predict(model, Xtest.obs)
#defining one colour for all observations or import external colours
if(forestFloor.col) {col = with(forestFloor_graphics.env,obs.indv.colours)} else {col="#20202050"}
#plot VEC-space versus predictions (only 2D and 3D plot supported)
if(d==2) { #if 2D VEC space
plot3d(x=values.to.plot[,1],y=values.to.plot[,2],z=yhat.obs,
xlab=names(X)[i.var][1],ylab=names(X)[i.var][2],main="VEC-SURFACE",col=col)
surface3d(x=scales[[1]],
y=scales[[2]],
z=yhat.vec,col="#404080",size=4,alpha=0.4)
}else{ #otherwise if 1D VEC-space
if(limitY) {ylim = range(rfo$y)} else {ylim = NULL}
plot(x=scales[[1]],y=yhat.vec,col="red",type="l",xlab=names(X)[i.var][1],ylim=ylim)
points(values.to.plot,yhat.obs)
}
}
surf.error = function()
surf.error = function() {
outs=replicate(knnBag, {  #the following is replicated/performed severeal ~20 times
this.boot.ind = sample(dim(XY)[1]*bag.ratio,replace=T) #pick a bootstrap from samples
sXY = scale(XY[this.boot.ind,])  #scale bootstrap to uni-variance
sgridXY = scale.by(scale.this=gridXY,by.this=sXY) #let grid be scaled as this bootstrap was scaled to sXY
out=knn.reg(train=sXY,
test=sgridXY,
y=axisval$z[this.boot.ind],
k=k,
algorithm="kd_tree")$pred  #predict grid from bootstrap of samples
})
}
obs=5000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + 2*sin(X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remeber to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,sampsize=800)
rfo
ff = forestFloor(rfo,X)
print(ff)
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
par(mfrow=c(2,3),mar=c(2,2,1,1))
for(i in 1:vars) vec.plot(X,rfo,i,zoom=1.5,limitY=T)
show3d(ff,x_cols=3,y_cols=4,z_cols=3:4,k=20,z_scale=1.1,font=1)
open3d()
vec.plot(X,rfo,3:4,zoom=2.5,grid.lines=100)
predict.randomForest
randomForest:::predict.randomForest
randomForest::predict.randomForest
?predict
obs=5000
vars = 6
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + 2*sin(X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remeber to include inbag
rfo=randomForest(X,Y,keep.inbag=TRUE,ntree=1000,sampsize=800)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
par(mfrow=c(2,3),mar=c(2,2,1,1))
par(mfrow=c(2,3),mar=c(2,2,1,1))
for(i in 1:vars) vec.plot(rfo,X,i,zoom=1.5,limitY=T)
source('~/Documents/PHD/Rlocal/svnff/forestfloor/pkg/forestFloor/R/forestFloor_source.R')
par()
pars=par()
par(pars)
?par
par(pars) #restore grphical paremeters
pars = par(no.readonly = TRUE) #save previous graphical par(emeters)
par(pars) #restore grphical paremeters
par(mfrow=c(2,3),mar=c(2,2,1,1))
for(i in 1:vars) vec.plot(rfo,X,i,zoom=1.5,limitY=T)
ff = forestFloor(rfo,X)
plot(ff,plot_seq=NULL,colour_by=2,col_axis=1)
for(i in 1:vars) vec.plot(rfo,X,i,zoom=1.5,limitY=T)
vec.plot(X,rfo,c(3,4),zoom=1,grid.lines=100)
vec.plot(X,rfo,c(3,4),zoom=1,grid.lines=100)
ls()
dim(X)
get("X")
vars
vec.plot(rfo,X,c(3,4),zoom=1,grid.lines=100)
vec.plot(rfo,X,c(3,4),zoom=1.5,grid.lines=100)
library(e1071)
library(help=e1071)
?svm
svm.model = svm(X,Y)
svm.model
svm.model = svm(as.matrix(X),Y)
svm.model
plot.svm(svm.model)
plot(svm.model)
plot(svm.model)
summary(svm.model)
Xtest = data.frame(replicate(vars,rnorm(obs)))
Ytest = with(Xtest, X1^2 + 2*sin(X2*pi) + 2 * X3 * (X4+.5))
predict(svm.model,Xtest)
plot(Ytest,predict(svm.model,Xtest))
cor(Ytest,predict(svm.model,Xtest))
cor(Ytest,predict(rfo,Xtest))
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=5)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=10)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=3)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=7)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=1)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=25)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=5)
cor(Ytest,predict(svm.model,Xtest))
vec.plot(svm.model,X,c(3,4),zoom=1.5,grid.lines=100)
vec.plot(svm.model,X,c(3,4),zoom=2.5,grid.lines=100)
plot(svm.model)
vec.plot(svm.model,X,c(1,2),zoom=2.5,grid.lines=100)
show3d(ff,x_cols=1,y_cols=2,z_cols=c(1,4),k=60,z_scale=1)
show3d(ff,x_cols=1,y_cols=2,z_cols=c(1,2),k=60,z_scale=1)
show3d(ff,x_cols=1,y_cols=2,z_cols=1:2,k=20,z_scale=1.1,font=1)
plot(ff,plot_seq=NULL,colour_by=1,col_axis=1)
show3d(ff,x_cols=1,y_cols=2,z_cols=1:2,k=20,z_scale=1.1,font=1)
plot(ff,plot_seq=NULL,colour_by=,col_axis=1)
plot(ff,plot_seq=NULL,colour_by=4,col_axis=1)
plot(ff,plot_seq=NULL,colour_by=4,col_axis=2)
vec.plot(svm.model,X,c(1,2),zoom=2.5,grid.lines=100)
obs=5000
vars = 6
Xtest = data.frame(replicate(vars,rnorm(obs)))
Ytest = with(Xtest, X1^2 + 4*sin(3*X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
X = data.frame(replicate(vars,rnorm(obs)))
Y = with(X, X1^2 + 4*sin(3*X2*pi) + 2 * X3 * (X4+.5))
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remeber to include inbag
rfo=randomForest(X,Y,keep.inbag=TRUE,ntree=1000,sampsize=800)
svm.model = svm(as.matrix(X),Y,cost=5)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=10)
svm.model = svm(as.matrix(X),Y,cost=1)
svm.model
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=10)
cor(Ytest,predict(svm.model,Xtest))
svm.model = svm(as.matrix(X),Y,cost=5,kernel="polynomial")
cor(Ytest,predict(svm.model,Xtest))
vec.plot(svm.model,X,c(1,2),zoom=2.5,grid.lines=100)
vec.plot(svm.model,Xtest,c(1,2),zoom=2.5,grid.lines=100)
svm.model = svm(as.matrix(X),Y,cost=5,kernel="radial")
cor(Ytest,predict(svm.model,Xtest))
vec.plot(svm.model,X,c(1,2),zoom=2.5,grid.lines=100)
par(mfrow=c(2,3),mar=c(2,2,1,1))
for(i in 1:vars) vec.plot(rfo,X,i,zoom=1.5,limitY=T)
for(i in 1:vars) vec.plot(svm.model,X,i,zoom=1.5,limitY=T)
