obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*2 + 2*sin(X2*pi) + (X3+max(0,X2))^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
#the pure feature contributions
obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*2 + 2*sin(X2*pi) + (X3+X2)^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(.1, #box.outliers squese all observations in a 2 std.dev box
.7*box.outliers(ff$X[,2]),        #univariately for a vector or matrix and normalize to [0;1]
.7*box.outliers(ff$X[,3]))
)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(.1, #box.outliers squese all observations in a 2 std.dev box
.7*box.outliers(ff$X[,2]),        #univariately for a vector or matrix and normalize to [0;1]
.7*box.outliers(ff$X[,3]))
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=90,zoom=2)
#apply grid on 3d-plot
persp3d(unique(grid34[,2]),unique(grid34[,3]),grid34[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid34[,2],grid34[,3],grid34[,1],alpha=0.3,col=c("black"),add=T)
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(.1, #box.outliers squese all observations in a 2 std.dev box
.7*box.outliers(ff$X[,2]),        #univariately for a vector or matrix and normalize to [0;1]
.7*box.outliers(ff$X[,3]))
)
source('~/Documents/PHD/Rlocal/svnff/forestfloor/pkg/forestFloor/R/forestFloor_source.R')
#simulate data
obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*2 + 2*sin(X2*pi) + (X3+X2)^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by="dummy, no defined color-template",col_axis=1,order_by_importance=F)
plot(ff,plot_seq=NULL,colour_by=2,col_axis=1,order_by_importance=F)
plot(ff,plot_seq=NULL,colour_by=2,col_axis=1,order_by_importance=T)
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500,importance=T)
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by=2,col_axis=1,order_by_importance=T)
plot(ff,plot_seq=NULL,colour_by=1,col_axis=1,order_by_importance=T)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(.1, #box.outliers squese all observations in a 2 std.dev box
.7*box.outliers(ff$X[,2]),        #univariately for a vector or matrix and normalize to [0;1]
.7*box.outliers(ff$X[,3]))
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^2, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5)^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])    ^2)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^2, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5)^2,        #univariately for a vector or matrix and normalize to [0;1]
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^2, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])    ^2)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^3, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^3,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])    ^3)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^1.5, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^3,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])    ^1.5)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])    ^1.5, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^1.5,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])    ^1.5)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^1.5, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^1.5)
)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^1.5, #box.outliers squese all observations in a 2 std.dev box
1-(box.outliers(ff$X[,2]-0.5))^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^1.5)
)
)
box.outliers(ff$X[,2])^1.5
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^1.5, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2]-0.5))^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^1.5)
)
)
abs(box.outliers(ff$X[,2]-0.5))
box.outliers(ff$X[,2]
)
hist(box.outliers(ff$X[,2]))
hist(abs(box.outliers(ff$X[,2]-0.5))
)
hist(box.outliers(ff$X[,2]-0.5))
hist(box.outliers(ff$X[,2]-1.5))
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^1.5, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^2,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^1.5)
)
)
hist(abs(box.outliers(ff$X[,2])-0.5))
hist(1-abs(box.outliers(ff$X[,2])-0.5)^2)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^2, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^.5,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^.5)
)
)
hist(box.outliers(ff$X[,2])^2)
hist(1-abs(box.outliers(ff$X[,2])-0.5)^.5)
plot(1-abs(box.outliers(sort(ff$X[,2]))-0.5)^.5)
plot(sort(box.outliers(ff$X[,2])^2))
plot(1- sort(box.outliers(ff$X[,2])^.5)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^2, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^.5,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2]^.5)
)
)
all(is.numeric(1-abs(box.outliers(ff$X[,2])-0.5)^.5))
all(1- box.outliers(ff$X[,2]^.5))
all(is.numeric(1- box.outliers(ff$X[,2]^.5))
)
all(is.numeric(box.outliers(ff$X[,2])^2))
range(box.outliers(ff$X[,2])^2))
range(box.outliers(ff$X[,2])^2)
range(1- box.outliers(ff$X[,2]^.5))
plot(1- sort(box.outliers(ff$X[,2])^2)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^2, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^.5,        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^2
)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=90,zoom=2)
#apply grid on 3d-plot
persp3d(unique(grid34[,2]),unique(grid34[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid34[,2],grid34[,3],grid34[,1],alpha=0.3,col=c("black"),add=T)
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=90,zoom=2)
persp3d(unique(grid34[,2]),unique(grid34[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=90,zoom=2)
#apply grid on 3d-plot
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid23[,2],grid23[,3],grid23[,1],alpha=0.3,col=c("black"),add=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=50,zoom=1.2)
#apply grid on 3d-plot
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid23[,2],grid23[,3],grid23[,1],alpha=0.3,col=c("black"),add=T)
grid123 = convolute_grid(ff,Xvars=c(1:3),FCvars=c(1:3),userArgs.kknn= alist(k=100,kernel="gaus",distance=1),grid=25,zoom=1.2)
25Â³
25^3
uni2 = unique(grid123[,2])  #2 points to X1 and FC1
uni2=uni2[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
for(i in uni2) {
count = count +1
this34.plane = grid234[grid234[,2]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,3]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
uni2 = unique(grid123[,2])  #2 points to X1 and FC1
uni2=uni2[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
count = 0
add=F
for(i in uni2) {
count = count +1
this34.plane = grid123[grid123[,2]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,3]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
## plotting any combination of X2 X3 in each layer(from red to green) having different value of X1
count = 0
add=F
for(i in uni2) {
count = count +1
this34.plane = grid123[grid123[,2]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,3]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
uni3 = unique(grid123[,3])  #2 points to X1 and FC1
uni3=uni3[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
## plotting any combination of X1 X3 in each layer(from red to green) having different value of X2
uni3 = unique(grid123[,3])  #2 points to X1 and FC1
uni3=uni3[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
for(i in uni3) {
count = count +1
this34.plane = grid123[grid123[,3]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,2]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
## plotting any combination of X1 X3 in each layer(from red to green) having different value of X2
uni3 = unique(grid123[,3])  #2 points to X1 and FC1
uni3=uni3[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
for(i in uni3) {
count = count +1
this34.plane = grid123[grid123[,3]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,2]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni3),1-count/length(uni3),0),alpha=0.1)
}
## plotting any combination of X1 X3 in each layer(from red to green) having different value of X2
uni3 = unique(grid123[,4])  #2 points to X1 and FC1
uni3=uni3[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
for(i in uni3) {
count = count +1
this34.plane = grid123[grid123[,4]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,2]),
unique(this34.plane[,3]),
this34.plane[,1], add=add, col=rgb(count/length(uni3),1-count/length(uni3),0),alpha=0.1)
}
#simulate data
obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*2 + 2*sin(X2*pi) + 3* (X3+X2)^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500,importance=T)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by=1,col_axis=1,order_by_importance=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=50,zoom=1.2)
#apply grid on 3d-plot
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid23[,2],grid23[,3],grid23[,1],alpha=0.3,col=c("black"),add=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=50,zoom=1.2)
#apply grid on 3d-plot
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid23[,2],grid23[,3],grid23[,1],alpha=0.3,col=c("black"),add=T)
#Make grid of three effects, 25^3 = 15625 anchor points
grid123 = convolute_grid(ff,Xvars=c(1:3),FCvars=c(1:3),userArgs.kknn= alist(k=100,kernel="gaus",distance=1),grid=25,zoom=1.2)
#Select a dimension to place in layers
uni2 = unique(grid123[,2])  #2 points to X1 and FC1
uni2=uni2[c(7,9,11,13,14,16,18)] #select some layers to visualize
## plotting any combination of X2 X3 in each layer(from red to green) having different value of X1
count = 0
add=F
for(i in uni2) {
count = count +1
this34.plane = grid123[grid123[,2]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,3]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*sin(X2*pi) + 3* (X3+X2)^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500,importance=T)
rfo
ff = forestFloor(rfo,X)
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by=1,col_axis=1,order_by_importance=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#simulate data
obs=5000
vars = 6
X = data.frame(replicate(vars,runif(obs)))*2-1
Y = with(X, X1*2 + 2*sin(X2*pi) + 3* (X3+X2)^2 )
Yerror = 1 * rnorm(obs)
var(Y)/var(Y+Yerror)
Y= Y+Yerror
#grow a forest, remember to include inbag
rfo=randomForest::randomForest(X,Y,keep.inbag=TRUE,ntree=1000,replace=T,sampsize=1500,importance=T)
#compute topology
ff = forestFloor(rfo,X)
#print forestFloor
print(ff)
#plot partial functions of most important variables first
plot(ff,plot_seq=NULL,colour_by=1,col_axis=1,order_by_importance=T)
#the pure feature contributions
plot3d(ff$X[,2],ff$X[,3],apply(ff$FCmatrix[,2:3],1,sum),
#add some colour gradients to ease visualization
col=rgb(   box.outliers(ff$X[,2])^3, #box.outliers squese all observations in a 2 std.dev box
1-abs(box.outliers(ff$X[,2])-0.5)^(1/3),        #univariately for a vector or matrix and normalize to [0;1]
1- box.outliers(ff$X[,2])^(1/3)
)
)
#add grid convolution/interpolation
#make grid with current function
grid23 = convolute_grid(ff,Xvars=2:3,userArgs.kknn= alist(k=25,kernel="gaus"),grid=50,zoom=1.2)
#apply grid on 3d-plot
persp3d(unique(grid23[,2]),unique(grid23[,3]),grid23[,1],alpha=0.3,col=c("black","grey"),add=T)
#anchor points of grid could be plotted also
plot3d(grid23[,2],grid23[,3],grid23[,1],alpha=0.3,col=c("black"),add=T)
## and we se that their is almost no variance out of the surface, thus is FC2 and FC3
## well explained by the feature context of both X3 and X4
### next example show how to plot a 3D grid + feature contribution, this 4D application is very experimental
#Make grid of three effects, 25^3 = 15625 anchor points
grid123 = convolute_grid(ff,Xvars=c(1:3),FCvars=c(1:3),userArgs.kknn= alist(k=100,kernel="gaus",distance=1),grid=25,zoom=1.2)
#Select a dimension to place in layers
uni2 = unique(grid123[,2])  #2 points to X1 and FC1
uni2=uni2[c(7,9,11,13,14,16,18)] #select some layers to visualize
## plotting any combination of X2 X3 in each layer(from red to green) having different value of X1
count = 0
add=F
for(i in uni2) {
count = count +1
this34.plane = grid123[grid123[,2]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,3]),
unique(this34.plane[,4]),
this34.plane[,1], add=add, col=rgb(count/length(uni2),1-count/length(uni2),0),alpha=0.1)
}
uni3 = unique(grid123[,4])  #2 points to X1 and FC1
uni3=uni3[c(7,9,11,13,14,16,18)] #select some layers to visualize
count = 0
add=F
for(i in uni3) {
count = count +1
this34.plane = grid123[grid123[,4]==i,]
if (count==2) add=T
#  plot3d(ff$X[,1],ff$X[,2]
persp3d(unique(this34.plane[,2]),
unique(this34.plane[,3]),
this34.plane[,1], add=add, col=rgb(count/length(uni3),1-count/length(uni3),0),alpha=0.1)
}
library(forestFloor)
