{
    "contents" : "#include <Rcpp.h>\nusing namespace Rcpp;\n\n//internal function to convert int to binary vector\nbool inbin(int bestsplit_groups, int obs_group) { \n  int divisionStore=0,modStore=0;\n  int i = 0;\n  do {\n      modStore=bestsplit_groups%2;\n      bestsplit_groups=bestsplit_groups/2;\n      i++;\n  } while(i < obs_group); //counting groups from 1.2....\n  return modStore==1;\n}\n\n//defining recursive function to iterate nodes\nvoid follow_path(\n//local recursive function environment                 \n                 bool calculate_node_pred,\n                 int i_tree,\n                 int this_node,\n                 double parent_pred,\n                 int parent_bestvar,\n                 int passed_OOB_count,\n                 int passed_IB_count,\n                 IntegerVector passed_innodes,\n                 IntegerVector train_innodes,\n//global R-objects\n                 NumericMatrix X,                  // 1  X\n                 NumericVector Y,\n                 IntegerMatrix leftDaughter,       // 6  LD\n                 IntegerMatrix rightDaughter,      // 7  RD\n                 IntegerMatrix nodestatus,         // 8  nodestatus\n                 NumericMatrix xbestsplit,         // 10 xsplits\n                 NumericMatrix nodepred,           // 11 averagetrainnodes\n                 IntegerMatrix bestvar,\n                 IntegerVector varLevels,          //12 bestvar\n                 NumericMatrix localIncrements) \n  {\n  \n   \n  //computing and adding the latest increment to localIncrements-matrix\n  double current_pred = 0;\n  if(calculate_node_pred) {\n    for(int thisIB_count = 0; thisIB_count<passed_IB_count;thisIB_count++) {\n      current_pred += Y(train_innodes(thisIB_count));\n    }\n    if(passed_IB_count>0) {\n      current_pred /= (passed_IB_count);\n    } else {\n      printf(\"error no IB \\n\");\n      current_pred = parent_pred;\n    }// divide sum of IB_preds with IB_count\n  } else { \n    current_pred = nodepred(this_node,i_tree); //reuse node_pred from RF-object, only regression\n  }\n  \n  \n  double this_increment = current_pred - parent_pred;\n  int outcome  = 0;\n  int this_obs = 0;\n    \n  for(int i_obs=0;i_obs<passed_OOB_count;i_obs++) {\n      this_obs = passed_innodes[i_obs];\n      localIncrements(this_obs,parent_bestvar) += this_increment;  \n  }\n\n  //if not a terminal node, split \n  if(passed_OOB_count>0) {\n    if(nodestatus(this_node,i_tree)==-3) { // #if this is not a terminal node\n      int current_bestvar = bestvar(this_node,i_tree);\n      int OOB_count_left  = 0;\n      int OOB_count_right = 0;\n      int IB_count_left   = 0;\n      int IB_count_right  = 0;\n      \n      IntegerVector OOBs_leftnode (passed_OOB_count);\n      IntegerVector OOBs_rightnode(passed_OOB_count);\n      IntegerVector IBs_leftnode (passed_IB_count);\n      IntegerVector IBs_rightnode(passed_IB_count);\n      \n      double this_split = xbestsplit(this_node,i_tree); // splitting-point\n      int this_int_split = this_split;                  // used if split point is categorical\n      int lev = varLevels(current_bestvar);             // get number of levels for this variable, >1 is categorical               \n      bool send_this_OOB_left;\n      bool send_this_IB_left;\n\n      //splitting OOB\n      for(int i_obs = 0;i_obs<passed_OOB_count;i_obs++) {\n        //lev==1, means numeric split, lev>1 means categorical split\n        if(lev==1) {\n        // numeric split, less than or equal goes left, see details section of help(getTree::randomForest)\n        send_this_OOB_left = X(passed_innodes[i_obs],current_bestvar) <= this_split; //split by X-value\n        } else {\n        //binary expansion is explained in details section of help(getTree::randomForest)\n        send_this_OOB_left = inbin(this_int_split,X(passed_innodes[i_obs],current_bestvar)+1); //split by binary expansion\n        }\n        if(send_this_OOB_left) {\n          OOBs_leftnode[OOB_count_left] = passed_innodes[i_obs];\n          OOB_count_left++;\n        } else {\n          OOBs_rightnode[OOB_count_right] = passed_innodes[i_obs];\n          OOB_count_right++;\n        }\n      }\n      \n      //splitting IB\n      //printf(\"passed ib count is %d \\n\", passed_IB_count);\n      if(calculate_node_pred) {\n        for(int i_obs = 0;i_obs<passed_IB_count;i_obs++) {\n        if(lev==1) {\n          // numeric split, less than or equal goes left, see details section of help(getTree::randomForest)\n          send_this_IB_left = X(train_innodes[i_obs],current_bestvar) <= this_split; //split by X-value\n        } else {\n          //binary expansion is explained in details section of help(getTree::randomForest)\n          send_this_IB_left = inbin(this_int_split,X(train_innodes[i_obs],current_bestvar)+1); //split by binary expansion\n        }\n        if(send_this_IB_left) {\n            IBs_leftnode[IB_count_left] = train_innodes[i_obs];\n            IB_count_left++;\n          } else {\n            IBs_rightnode[IB_count_right] = train_innodes[i_obs];\n            IB_count_right++;\n          }\n        }\n      }\n      //printf(\"got to here, left %d right %d \\n\",IB_count_left,IB_count_right);\n      //for(int i_print=0;i_print<IB_count_left;i_print++) printf(\"%d %d \\n \",i_print,IBs_leftnode(i_print));\n      \n      \n      //initiate left step\n      if(OOB_count_left>0) {\n      follow_path(\n//local recursive function environment                 \n        calculate_node_pred,\n        i_tree,\n        leftDaughter(this_node,i_tree),\n        current_pred,\n        current_bestvar,\n        OOB_count_left,\n        IB_count_left,\n        OOBs_leftnode,\n        IBs_leftnode,\n//pointers to global R-objects\n        X,                  // 1  X\n        Y,\n        leftDaughter,       // 6  LD\n        rightDaughter,      // 7  RD\n        nodestatus,         // 8  nodestatus\n        xbestsplit,         // 10 xsplits\n        nodepred,           // 11 averagetrainnodes\n        bestvar,            //12 bestvar\n        varLevels,\n        localIncrements);\n        OOB_count_left=0;\n        //Rprintf(\"going back from left, now in %d \\n\",this_node);\n        //if(outcome != 0) return outcome;\n      }\n      \n      //... came back from a left step, now going right\n      if(OOB_count_right>0) {\n        follow_path(\n        calculate_node_pred,\n        i_tree,\n        rightDaughter(this_node,i_tree),\n        current_pred,\n        current_bestvar,\n        OOB_count_right,\n        IB_count_right,\n        OOBs_rightnode,\n        IBs_rightnode,\n        X,                  // 1  X\n        Y,\n        leftDaughter,       // 6  LD\n        rightDaughter,      // 7  RD\n        nodestatus,         // 8  nodestatus\n        xbestsplit,         // 10 xsplits\n        nodepred,           // 11 averagetrainnodes\n        bestvar,            //12 bestvar\n        varLevels,\n        localIncrements);\n        OOB_count_right=0;\n        //Rprintf(\"going back from righ, now in %d \\n\",this_node);\n        //if(outcome != 0) return outcome;\n        }\n        \n        \n      //... came back from a right step, all nodes below have been completed\n        nodestatus(this_node,i_tree)==-1;\n    }\n  }\n  //got to here as node was terminal or all nodes below have been checked\n  //Now leaving node going up. Next OOB indices is saved locally in upper node as OOBs_leftnode or OOBs_rightnode\n  // if upper node is rootnode, the path will be terminated\n  //no returns all changes were applied to global NumericVector localIncrements\n//return 0;\n}\n\n\n/// defining Rcpp function to communicate with R\n//[[Rcpp::export]]\nvoid recTree(int  vars,               //local 3  nvar\n            int  obs,                 //local 4  nobs\n            int  ntree,               //local  5  ntrees\n            bool calculate_node_pred, //should node prediction\n            NumericMatrix X,                  // 1  X\n            NumericVector Y,\n            IntegerMatrix leftDaughter,       // 6  LD\n            IntegerMatrix rightDaughter,      // 7  RD\n            IntegerMatrix nodestatus,         // 8  nodestatus\n            NumericMatrix xbestsplit,         // 10 xsplits\n            NumericMatrix nodepred,           // 11 averagetrainnodes\n            IntegerMatrix bestvar,            // 12 bestvar\n            IntegerMatrix inbag,\n            IntegerVector varLevels,\n            IntegerVector OOBtimes,\n            NumericMatrix localIncrements)    // 15 inbag obsXtrees\n{\n  \n  \n  //declare internal function variables\n  IntegerVector innodes_root(obs);        //list of OOBs \n  IntegerVector train_innodes_root(obs);  //list of IBs\n  int this_bagcount = 0;\n  int times_inbag = 0;\n  int OOB_count = 0;\n  int IB_count = 0;\n  int outcome = 0;\n  double root_pred = 0;\n  \n  //iterate each tree and compute and sum to localIncrements\n  for(int i_tree=0;i_tree<ntree;i_tree++){\n    \n    //make ranges of Out Of Bag and inbag observations in root of tree\n    OOB_count = 0;  //reset OOB_count for this new tree\n    IB_count  = 0 ; \n    root_pred =  0;\n    for(int i_obs=0;i_obs<obs;i_obs++) {  // for all observations \n      this_bagcount = inbag(i_obs,i_tree);// how many time was obs used in tree, 0,1,2,3...\n      if(this_bagcount==0) {              // if obs was used 0 times, it is OOB\n        innodes_root[OOB_count] = i_obs;  // add observation_indice to list\n        OOB_count++;\n      } else {\n        if(calculate_node_pred) {\n          for(times_inbag = this_bagcount;times_inbag>0;times_inbag--) {\n            train_innodes_root[IB_count] = i_obs;\n            root_pred += Y(i_obs);\n            IB_count++;\n          }\n        }  \n      }     \n    }\n    \n    if(calculate_node_pred) {\n      root_pred /= IB_count;\n    } else {\n      root_pred= nodepred(0,i_tree);\n    }\n    \n    \n    //printf(\"root pred %f \\n\",root_pred);\n\n    //initiating varibles for recursive search of tree\n  \n     follow_path(\n//local recursive function environment                 \n        calculate_node_pred,\n        i_tree,\n        0,   //start in root node, 0\n        root_pred, //parent_pred set to root_pred,\n        0,    //dummy number, any var within X vars will do \n        OOB_count,  //how many obs OOB to start with in root node\n        IB_count,\n        innodes_root,  //X.rows indices of OOB observations in rootnode\n        train_innodes_root,\n//pointers to global R-objects\n        X,                  // 1  X dataset\n        Y,\n        leftDaughter,       // 6  LD\n        rightDaughter,      // 7  RD\n        nodestatus,         // 8  nodestatus\n        xbestsplit,         // 10 xsplits\n        nodepred,           // 11 averagetrainnodes\n        bestvar,            //12 bestvar\n        varLevels,\n        localIncrements);\n       // if(outcome != 0) return outcome;\n  } // go to next tree\n  \n  //divide sum of increments with trees iterated and mulitiply with 0\n  int timesUsed=0;\n  for(int i_obs=0;i_obs<obs;i_obs++){\n    timesUsed = OOBtimes(i_obs);\n    for(int i_vars=0;i_vars<vars;i_vars++){\n      localIncrements(i_obs,i_vars) /= timesUsed;\n    }\n  }\n\n}",
    "created" : 1419354842806.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "954906514",
    "id" : "3AFE3BD2",
    "lastKnownWriteTime" : 1420204773,
    "path" : "~/Documents/PHD/Rlocal/forestFloor/src/testcpp_rec6.cpp",
    "project_path" : "src/testcpp_rec6.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}